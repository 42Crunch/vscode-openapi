/*
 Copyright (c) 42Crunch Ltd. All rights reserved.
 Licensed under the GNU Affero General Public License version 3. See LICENSE.txt in the project root for license information.
*/

import FormData from "form-data";
import got, { RequestError } from "got";
import http from "http";
import https from "https";
import { URL } from "url";

import {
  HttpConfig,
  HttpError,
  HttpRequest,
  HttpResponse,
  ShowHttpErrorMessage,
  ShowHttpResponseMessage,
} from "@xliic/common/http";

import { LogBuilder, Scope } from "../log-redactor";
import { Logger } from "../platform/types";
import { createProxyAgentsAndCerts } from "../proxy";
import { LogLevel } from "vscode";

const redactor = new LogBuilder()
  .addHeaderRules("X-API-KEY", "Authorization")
  .addQueryRule("token")
  .addUuidTokenRegExpRule("REQUEST_BODY")
  .build();

export async function executeHttpRequest(
  id: string,
  request: HttpRequest,
  config: HttpConfig,
  logger: Logger
): Promise<ShowHttpResponseMessage | ShowHttpErrorMessage> {
  try {
    const response = await executeHttpRequestRaw(request, config, logger);
    return {
      command: "showHttpResponse",
      payload: { id, response },
    };
  } catch (e) {
    return {
      command: "showHttpError",
      payload: { id, error: e as HttpError },
    };
  }
}

export async function executeHttpRequestRaw(
  request: HttpRequest,
  config: HttpConfig,
  logger: Logger
): Promise<HttpResponse> {
  const { url, method, headers, body } = request;

  const restoredBody = restoreBody(body, getContentType(headers));

  // drop Content-Type header if multipart/form-data
  // correct Content-Type will be generated by the client, and will include
  // proper boundary
  if (isMultipartFormData(body, getContentType(headers))) {
    for (const name of Object.keys(headers)) {
      if (name.toLowerCase() == "content-type") {
        delete headers[name];
      }
    }
  }

  const isHttpsUrl = url.toLowerCase().startsWith("https://");

  const proxy = await createProxyAgentsAndCerts(config.https?.proxy);

  const requestFn =
    proxy !== undefined
      ? isHttpsUrl
        ? (https as any).__vscodeOriginal?.request
        : (http as any).__vscodeOriginal?.request
      : undefined;

  const options = {
    throwHttpErrors: false,
    method,
    body: restoredBody,
    headers: {
      ...headers,
    },
    https: {
      rejectUnauthorized: config?.https?.rejectUnauthorized ?? true,
      certificateAuthority: proxy !== undefined ? proxy.certs : undefined,
    },
    retry: {
      limit: 0,
    },
    request: requestFn,
    agent: proxy?.agents,
    hooks: getHooks(method, logger),
  };

  try {
    const response = await got(url, options);

    const responseHeaders: [string, string][] = [];
    for (let i = 0; i < response.rawHeaders.length; i += 2) {
      responseHeaders.push([response.rawHeaders[i], response.rawHeaders[i + 1]]);
    }

    return {
      statusCode: response.statusCode,
      statusMessage: response.statusMessage,
      body: response.body,
      httpVersion: response.httpVersion,
      headers: responseHeaders,
    };
  } catch (e: unknown) {
    const { code, message } = e as RequestError;
    const sslError = isSslError(code);
    throw {
      code,
      message,
      sslError,
    };
  }
}

function getContentType(headers: HttpRequest["headers"]): string | undefined {
  for (const [key, value] of Object.entries(headers)) {
    const name = key.toLowerCase();
    if (name == "content-type") {
      return value;
    }
  }
}

function isMultipartFormData(body: unknown, contentType: string | undefined) {
  return body && contentType === "multipart/form-data";
}

function restoreBody(body: unknown, contentType: string | undefined): any {
  if (isMultipartFormData(body, contentType)) {
    const form = new FormData();
    for (const [key, value] of body as [string, string][]) {
      form.append(key, value);
    }
    return form;
  }
  return body;
}

function isSslError(code: string): boolean {
  const codes = [
    "UNABLE_TO_GET_ISSUER_CERT",
    "UNABLE_TO_GET_CRL",
    "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
    "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
    "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
    "CERT_SIGNATURE_FAILURE",
    "CRL_SIGNATURE_FAILURE",
    "CERT_NOT_YET_VALID",
    "CERT_HAS_EXPIRED",
    "CRL_NOT_YET_VALID",
    "CRL_HAS_EXPIRED",
    "ERROR_IN_CERT_NOT_BEFORE_FIELD",
    "ERROR_IN_CERT_NOT_AFTER_FIELD",
    "ERROR_IN_CRL_LAST_UPDATE_FIELD",
    "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
    "OUT_OF_MEM",
    "DEPTH_ZERO_SELF_SIGNED_CERT",
    "SELF_SIGNED_CERT_IN_CHAIN",
    "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
    "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
    "CERT_CHAIN_TOO_LONG",
    "CERT_REVOKED",
    "INVALID_CA",
    "PATH_LENGTH_EXCEEDED",
    "INVALID_PURPOSE",
    "CERT_UNTRUSTED",
    "CERT_REJECTED",
    "HOSTNAME_MISMATCH",
  ];

  return codes.includes(code);
}

export function getHooks(method: string, logger: Logger) {
  const logResponse = (response: any, retryWithMergedOptions: Function) => {
    const logLevel = logger.getLogLevel();
    if (logLevel !== LogLevel.Off && logLevel <= LogLevel.Debug) {
      redactor.setRedactionEnabled(logger.isRedactionEnabled());
      logger.debug(`${method} ${getSafeUrl(response.url)} ${response.statusCode}`);
    }
    return response;
  };

  const logRequest = (options: any) => {
    const logLevel = logger.getLogLevel();
    if (logLevel !== LogLevel.Off && logLevel <= LogLevel.Trace) {
      redactor.setRedactionEnabled(logger.isRedactionEnabled());
      const body = options.json
        ? redactor.redact(JSON.stringify(options.json), "REQUEST_BODY")
        : "";
      const safeUrl = getSafeUrl(`${options.prefixUrl}${options.url}`);
      if (options.headers) {
        const headers = [];
        for (const name of Object.keys(options.headers)) {
          const value = options.headers[name];
          headers.push(name + ":" + redactor.redactFieldValue(name, value, "REQUEST_HEADER"));
        }
        logger.trace(`${method} ${safeUrl} headers=[${headers.join(",")}] ${body}`);
      } else {
        logger.trace(`${method} ${safeUrl} ${body}`);
      }
    }
  };

  return {
    beforeRequest: [logRequest],
    afterResponse: [logResponse],
  };
}

export function getSafeUrl(url: string): string {
  try {
    const myUrl = new URL(url);
    if (myUrl.search) {
      const safeUrl = new URL(url);
      safeUrl.search = "";
      const newSearchParams = safeUrl.searchParams;
      myUrl.searchParams.forEach((value, name, _searchParams) => {
        if (value) {
          const safeValue = redactor.redactFieldValue(name, value, "REQUEST_QUERY");
          newSearchParams.append(name, safeValue);
        } else {
          newSearchParams.append(name, value);
        }
      });
      // URLSearchParams object uses rules to determine which characters to percent-encode
      // For example [ and ] will always be encoded to %5 and %5D
      return safeUrl.toString().replace("%5BREDACTED%5D", "[REDACTED]");
    }
  } catch (error) {
    return url;
  }
  return url;
}
