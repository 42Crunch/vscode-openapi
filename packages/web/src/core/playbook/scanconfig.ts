/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type ConfigurationFileBundle = GlobalFile & {
  operations?: {
    [k: string]: Operation;
  };
  requests?: {
    [k: string]: RequestFile;
  };
  environments?: {
    [k: string]: EnvironmentFile;
  };
  [k: string]: unknown;
};
/**
 * An array of HTTP response status codes that the scan expects for the request.
 */
export type ResponseHttpStatusExpected = string[];
/**
 * An array of authentication requests to be fullfilled.
 */
export type AuthArray = (string | Credential)[] | null;
/**
 * This interface was referenced by `CtxVariables`'s JSON-Schema definition
 * via the `patternProperty` ".*".
 */
export type UserInputValue =
  | unknown[]
  | {
      [k: string]: unknown;
    }
  | string
  | number
  | boolean
  | null;
/**
 * An array of authentication requests to be fullfilled.
 */
export type AuthArray1 = (string | Credential1)[] | null;
/**
 * An array of path parameters
 */
export type ParametersArray = {
  /**
   * Parameter's name
   */
  key: string;
  value: UserInputValue;
}[];
/**
 * An array of query parameteres, which is basically the query string part of the URL, parsed into separate variables
 */
export type ParametersArray1 = {
  /**
   * Parameter's name
   */
  key: string;
  value: UserInputValue;
}[];
/**
 * An array of header parameters
 */
export type ParametersArray2 = {
  /**
   * Parameter's name
   */
  key: string;
  value: UserInputValue;
}[];
/**
 * An array of cookie parameters
 */
export type ParametersArray3 = {
  /**
   * Parameter's name
   */
  key: string;
  value: UserInputValue;
}[];
/**
 * A JSON value to be included in the request body.
 */
export type UserInputValue1 =
  | unknown[]
  | {
      [k: string]: unknown;
    }
  | string
  | number
  | boolean
  | null;
/**
 * An array of requests to execute
 */
export type RequestsStage = (RequestStageReference | RequestStageContent)[];
/**
 * An array of requests to execute
 */
export type RequestsStage1 = (RequestStageReference | RequestStageContent)[];
/**
 * An array of requests to execute
 */
export type RequestsStage2 = (RequestStageReference | RequestStageContent)[];
/**
 * An array of requests to execute
 */
export type RequestsStage3 = (RequestStageReference | RequestStageContent)[];
/**
 * Array of plugins command to execute
 */
export type HooksPluginReference = string[];
/**
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` ".*".
 */
export type Operation = ScenarioFile & {
  request: RequestFile;
  [k: string]: unknown;
};
/**
 * Array of requests to be sent once before running scenarios
 */
export type Before = (RequestStageReference | RequestStageContent)[];
/**
 * Array of requests to be sent once after running scenarios
 */
export type After = (RequestStageReference | RequestStageContent)[];
/**
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` ".*".
 */
export type RequestFile = RequestStageContent & {
  /**
   * ID of the operation in the specification file
   */
  operationId?: string;
  [k: string]: unknown;
};
export type UserInputValue2 =
  | unknown[]
  | {
      [k: string]: unknown;
    }
  | string
  | number
  | boolean
  | null;
/**
 * Determines the default value when the environment variable is not defined in the config file or in the os. The default property is not needed when 'required' is true
 */
export type UserInputValue3 =
  | unknown[]
  | {
      [k: string]: unknown;
    }
  | string
  | number
  | boolean
  | null;

export interface GlobalFile {
  /**
   * file's version
   */
  version: "2.0.0";
  runtimeConfiguration?: RuntimeConfiguration;
  customizations?: Customizations;
  authorizationTests?: {
    /**
     * This interface was referenced by `undefined`'s JSON-Schema definition
     * via the `patternProperty` ".*".
     */
    [k: string]: AuthenticationSwappingTest;
  };
  authenticationDetails?: (
    | {
        /**
         * Reference to a scan credential stored in a scan vault.
         */
        $ref: string;
      }
    | {
        [k: string]: Credential;
      }
  )[];
  apiVersion?: RequestsStage1;
  before?: RequestsStage2;
  after?: RequestsStage3;
  /**
   * Hold all plugins reference used in request and response during the runtime execution
   */
  hooks?: {
    requests?: HooksPluginReference;
    responses?: HooksPluginReference;
  };
  [k: string]: unknown;
}
export interface RuntimeConfiguration {
  /**
   * Default environment to be loaded if none is specified at scan runtime
   */
  environment?: string;
  /**
   * The level of detail in logs set for the scan.
   */
  logLevel?: "debug" | "info" | "error" | "critical";
  /**
   * The destination of all logs produced during the scan. The possible values are'stdout','files', and 'platform'. You can select multiple outputs by adding the character '+' between the values.
   */
  logDestination?: string;
  /**
   * The maximum size (in bytes) of the log file when the 'logDestination' value includes 'files'.
   */
  logMaxFileSize?: number;
  /**
   * The name of the header that contains the request ID of the sent request.
   */
  requestHeaderNameRequestId?: string;
  /**
   * The name of the header that contains the scenario ID of the sent request.
   */
  requestHeaderNameScenarioId?: string;
  /**
   * The time interval (in milliseconds) between the requests that the scan sends to the API during a scan.
   */
  requestFlowrate?: number;
  /**
   * The maximum time (in seconds) that the scan waits for a response from the API. It is not recommended to set this value to '0', because that means the scan would wait forever for the API to respond, causing the scan to hang if the API is unresponsive.
   */
  requestTimeout?: number;
  /**
   * This setting defines if the scan accepts any certificate presented by the server and any host name in that certificate
   */
  requestTlsInsecureSkipVerify?: boolean;
  /**
   * This setting defines if the scan follows the 'HTTP 302 Redirection' response. Maximum of 10 successive redirections are allowed before the scan stops.
   */
  responseFollowRedirection?: boolean;
  /**
   * This setting controls which requests are included in the scan. By default, the scan first sends happy path requests to establish the baseline for how the normal API behavior, then the actual test requests to detect any problems in how the API implementation conforms to the API definition. If you set this setting to 'true', the scan only runs the happy path requests during the scan before stopping, instead of a full scan.
   */
  happyPathOnly?: boolean;
  /**
   * The maximum duration (in seconds) allowed for executing the scan. The scan times out if the the execution takes longer.
   */
  maxScanDuration?: number;
  /**
   * A soft limit (in bytes) for the maximum amount of memory that the scan process is allowed to consume.
   */
  memoryLimit?: number;
  /**
   * The time interval (in seconds) how often the scan process checks the current memory consumption.
   */
  memoryTimeSpan?: number;
  /**
   * The maximum body size (in bytes) that the scan consumes from an API response, to avoid massive memory consumption.
   */
  responseMaxBodySizeScan?: number;
  /**
   * Is the scan report indexed or not. Indexing the report (set to 'true') can reduce the report size, but it may make it less human-readable.
   */
  reportIndexed?: boolean;
  /**
   * Is the scan report prettified or not. Prettifying the scan report increases its human-readability, but it also increases the report size.
   */
  reportPrettify?: boolean;
  /**
   * The maximum size (in bytes) of the HTTP responses received for a happy path request that is included in the scan report.
   */
  reportMaxHttpResponseSizeHappyPath?: number;
  /**
   * The maximum body size (in bytes) that the scan includes in the scan report for a happy path request.
   */
  reportMaxBodySizeHappyPath?: number;
  /**
   * The maximum size (in bytes) of the HTTP responses received for an actual test request that is included in the scan report.
   */
  reportMaxHttpResponseSizeTest?: number;
  /**
   * The maximum body size (in bytes) that the scan includes in the scan report for an actual test request.
   */
  reportMaxBodySizeTest?: number;
  /**
   * This setting determines what results are included in the scan report. If set to 'true', only test requests that uncovered problems in your API implementation are included in the scan report, to avoid overly large report size. If set to 'false', both requests that uncovered problems and the ones that did not (so where all was good) are included in the scan report, significantly increasing the report size.
   */
  reportIssuesOnly?: boolean;
  /**
   * The maximum number of problems that the scan can uncover before it must stop. This setting helps to control the report size: you can iterate on scanning your API, and as you fix the problems found in previous scans, the scan keeps including subsequently discovered problems.
   */
  reportMaxIssues?: number;
  /**
   * The maximum scan report size (in bytes). The scan stops when the size limit is reached.
   */
  reportMaxSize?: number;
  /**
   * Generate the corresponding curl command for each tested request. Note: This will increase the report size twofold.
   */
  reportGenerateCurlCommand?: boolean;
}
/**
 * Customize scan behavior for happys paths and tests
 */
export interface Customizations {
  happyPaths?: {
    /**
     * The number of retry attempts that the scan performs for a happy path request. A successfully performed happy path request is required to establish a baseline before the scan can run any actual test requests on the operation.
     */
    retry: number;
    responsePolicy: ResponsePolicy;
    httpStatusExpected: ResponseHttpStatusExpected;
    [k: string]: unknown;
  };
  tests?: {
    /**
     * An array of test IDs to be skipped in the scan, defined at the playbook level.
     */
    skippedKeys?: string[];
    responsePolicy: ResponsePolicy;
    responseAnalysisBehavior: {
      [k: string]: ResponseAnalysisBehavior;
    };
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
export interface ResponsePolicy {
  httpStatusExpected?: boolean;
  mustBeConformant?: boolean;
}
/**
 * Defines what the scan expects regarding the response status code, header and body assessment.
 *
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` ".*".
 */
export interface ResponseAnalysisBehavior {
  httpStatusExpected?: ResponseHttpStatusExpected;
}
export interface AuthenticationSwappingTest {
  key: "authentication-swapping-bola" | "authentication-swapping-bfla";
  source: AuthArray;
  target: AuthArray;
  [k: string]: unknown;
}
/**
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` ".*".
 */
export interface Credential {
  /**
   * Security scheme type
   */
  type: "basic" | "bearer" | "apiKey" | "oauth2" | "openIdConnect";
  description?: string;
  /**
   * The default credential stored in your scan vault that the scan uses for authenication if no other credential is defined for a test. The value must be a key in your credentials map.
   */
  default: string;
  credentials: {
    [k: string]: CredentialContent;
  };
  /**
   * The idle time before re-running requests defined for each credentials value. 'ParseDuration' parses this to a duration string, such as '300s', '300ms', '1h',  valid time units are 'ns', 'us' (or 'µs'), 'ms', 's', 'm', 'h'.
   */
  tti?: string;
  /**
   * The hard time before re-running requests defined for each credentials values. 'ParseDuration' parses this to a duration string, such as '300s', '300ms', '1h',  valid time units are 'ns', 'us' (or 'µs'), 'ms', 's', 'm', 'h'.
   */
  ttl?: string;
  /**
   * The location of the API key. Valid values are 'query', 'header' or 'cookie'
   */
  in?: string;
  /**
   * The name of the header, query or cookie parameter to be used.
   */
  name?: string;
}
/**
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` ".*".
 */
export interface CredentialContent {
  type?: string;
  description?: string;
  requests?: RequestsStage;
  credential: string;
}
/**
 * A scenario stage to be executed by the scan
 */
export interface RequestStageReference {
  /**
   * A reference to a request. Other properties except '$ref/request' can be ovewritten.
   */
  $ref: string;
  environment?: CtxVariables;
  auth?: AuthArray1;
  responses?: Responses;
  /**
   * Describe the type of injection done for a specific request. Can be used only in the scenarios.json file under the customTests properties
   */
  injectionKey?: string;
  /**
   * Uses the request defined in the scenario as a baseline to run conformance and authorization tests. It can only have one property 'fuzzing' set to true per scenarios.json file. Can be used only in the scenarios.json
   */
  fuzzing?: boolean;
  /**
   * Reference to a response defined in the 'responses' map and ignore the one specified in the defaultResponse
   */
  expectedResponse?: string;
}
/**
 * A map for storing user-defined variables that are needed in the scenario.
 */
export interface CtxVariables {
  [k: string]: UserInputValue;
}
export interface Credential1 {
  /**
   * Security scheme type
   */
  type: "basic" | "bearer" | "apiKey" | "oauth2" | "openIdConnect";
  description?: string;
  /**
   * The default credential stored in your scan vault that the scan uses for authenication if no other credential is defined for a test. The value must be a key in your credentials map.
   */
  default: string;
  credentials: {
    [k: string]: CredentialContent1;
  };
  /**
   * The idle time before re-running requests defined for each credentials value. 'ParseDuration' parses this to a duration string, such as '300s', '300ms', '1h',  valid time units are 'ns', 'us' (or 'µs'), 'ms', 's', 'm', 'h'.
   */
  tti?: string;
  /**
   * The hard time before re-running requests defined for each credentials values. 'ParseDuration' parses this to a duration string, such as '300s', '300ms', '1h',  valid time units are 'ns', 'us' (or 'µs'), 'ms', 's', 'm', 'h'.
   */
  ttl?: string;
  /**
   * The location of the API key. Valid values are 'query', 'header' or 'cookie'
   */
  in?: string;
  /**
   * The name of the header, query or cookie parameter to be used.
   */
  name?: string;
}
/**
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` ".*".
 */
export interface CredentialContent1 {
  type?: string;
  description?: string;
  requests?: RequestsStage;
  credential: string;
}
/**
 * Response map returned by the API. Keys in the map are free-form
 */
export interface Responses {
  [k: string]: Response;
}
/**
 * Describe the response returned by the API.
 *
 * This interface was referenced by `Responses`'s JSON-Schema definition
 * via the `patternProperty` ".*".
 */
export interface Response {
  /**
   * Assess the API's response with expectations.
   */
  expectations: {
    httpStatus: number | ("default" | "1XX" | "2XX" | "3XX" | "4XX" | "5XX");
    [k: string]: unknown;
  };
  variableAssignments?: VariableAssignments;
  [k: string]: unknown;
}
/**
 * Allows defining variables by extracting response/request content at header or body level.
 */
export interface VariableAssignments {
  /**
   * This interface was referenced by `VariableAssignments`'s JSON-Schema definition
   * via the `patternProperty` ".*".
   */
  [k: string]:
    | VariableAssignmentsHardcoded
    | VariableAssignmentsContext
    | VariableAssignmentsParameter
    | VariableAssignmentsBody;
}
export interface VariableAssignmentsHardcoded {
  /**
   * TODO
   */
  from: "hardcoded";
  /**
   * The variable name in the context
   */
  name?: string;
  [k: string]: unknown;
}
export interface VariableAssignmentsContext {
  /**
   * TODO
   */
  from: "context";
  /**
   * The variable name in the context
   */
  name?: string;
  [k: string]: unknown;
}
export interface VariableAssignmentsParameter {
  /**
   * Allows to specify whether a variable should be loaded in the request or response
   */
  from?: "request" | "response";
  /**
   * Determines the location of a variable within an API request or response
   */
  in?: "header" | "query" | "path" | "cookie";
  /**
   * Specify the name of the header/query or path parameter to fetch the data
   */
  name?: string;
  [k: string]: unknown;
}
export interface VariableAssignmentsBody {
  /**
   * Allows to specify whether a variable should be loaded in the request or response
   */
  from?: "request" | "response";
  /**
   * Determines the location of a variable within an API request or response
   */
  in?: "body";
  /**
   * Specify the 'Content-Type' of the data being sent or received in an API request or response
   */
  contentType?: "json";
  /**
   * Provides instructions on how to extract and load a variable from the body of an HTTP request or response.
   */
  path?: {
    /**
     * Type of syntax for identifying a specific value to fetch in the body
     */
    type?: "jsonPointer" | "jsonPath";
    /**
     * Value of the pointer to identify the specific value to fetch in the body
     */
    value?: string;
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * A request stage to be executed by the scan
 */
export interface RequestStageContent {
  environment?: CtxVariables;
  auth?: AuthArray1;
  /**
   * Contains all the data needed to send an HTTP request.
   */
  request: CRequest | HttpRequest;
  /**
   * Default response in case no 'expectedResponse' is specified when referencing the request. This is a key that refers to an object inside the 'responses' property
   */
  defaultResponse: string;
  responses: Responses;
  /**
   * Describe the type of injection done for a specific request. Can be used only in the scenarios.json file under the customTests properties
   */
  injectionKey?: string;
  /**
   * Uses the request defined in the scenario as a baseline to run conformance and authorization tests. It can only have one property 'fuzzing' set to true per scenarios.json file. Can be used only in the scenarios.json
   */
  fuzzing?: boolean;
  [k: string]: unknown;
}
/**
 * Contains all the data needed to send an HTTP request with the 42c format.
 */
export interface CRequest {
  /**
   * Format for describing the request
   */
  type: "42c";
  details: {
    operationId?: string;
    method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "HEAD" | "TRACE" | "OPTIONS";
    /**
     * The string representation of the request URL, including the protocol, host, path, hash and path variable(s). Query parameter(s) must be included in the 'query' object. Fragment URL is not supported yet.
     */
    url: string;
    paths?: ParametersArray;
    queries?: ParametersArray1;
    headers?: ParametersArray2;
    cookies?: ParametersArray3;
    requestBody?:
      | null
      | (
          | {
              /**
               * Type of the request body
               */
              mode: "raw";
              raw: string;
              options?: {
                raw: {
                  language?: "json";
                  [k: string]: unknown;
                };
                [k: string]: unknown;
              };
            }
          | {
              /**
               * Type of the request body
               */
              mode: "json";
              json: UserInputValue1;
            }
          | {
              /**
               * Type of the request body
               */
              mode: "urlencoded";
              /**
               * Map of urlencoded value to send value to send in the body
               */
              urlencoded: {
                [k: string]: UrlencodedObject;
              };
            }
        );
  };
}
/**
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` ".*".
 */
export interface UrlencodedObject {
  value: UserInputValue;
}
/**
 * The http format that describes the HTTP requests that the scan sends.
 */
export interface HttpRequest {
  /**
   * Format for describing the request
   */
  type?: "http";
  http?: {
    protocol: string;
    http: string;
  };
  [k: string]: unknown;
}
export interface ScenarioFile {
  /**
   * Reference to a definition of an authorization test in the common.json. The fuzzedRequest in the happy path must have the authentication that match the source in the test.
   */
  authorizationTests?: string[];
  /**
   * Array of user-defined custom requests to be sent at operation level.
   */
  customTests?: CustomTest[];
  before?: Before;
  after?: After;
  scenarios: (HappyPathScenario | UnhappyPathScenario)[];
  /**
   * ID of the operation in the specification file
   */
  operationId?: string;
  [k: string]: unknown;
}
export interface CustomTest {
  requests: RequestsStage;
  key?: string;
}
export interface HappyPathScenario {
  /**
   * Describe all requests defined in the scenario represents a happy or unhappy path scenario.
   */
  key: "happy.path";
  requests?: RequestsStage;
  /**
   * The scenario will be used as a baseline to run the tests
   */
  fuzzing?: boolean;
}
export interface UnhappyPathScenario {
  /**
   * Describe all requests defined in the scenario represents a happy or unhappy path scenario.
   */
  key: "unhappy.path";
  requests?: RequestsStage;
}
/**
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` ".*".
 */
export interface EnvironmentFile {
  /**
   * A map for storing user-defined variables that are needed in the scenario.
   */
  variables: {
    /**
     * This interface was referenced by `undefined`'s JSON-Schema definition
     * via the `patternProperty` ".*".
     */
    [k: string]:
      | (
          | unknown[]
          | {
              [k: string]: unknown;
            }
          | string
          | number
          | boolean
          | null
        )
      | HardcodedVariable
      | {
          from: "environment";
          /**
           * Environment name to fetch in the config file or in the os.
           */
          name?: string;
          /**
           * Determines whether the environment variable is mandatory
           */
          required: boolean;
          default?: UserInputValue3;
          [k: string]: unknown;
        };
  };
}
export interface HardcodedVariable {
  from: "hardcoded";
  value: UserInputValue2;
  [k: string]: unknown;
}
